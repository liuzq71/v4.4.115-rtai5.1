<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>RTAI API: Inter-process communications.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RTAI API
   &#160;<span id="projectnumber">5.1</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('group__fifos__ipc.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Inter-process communications.<div class="ingroups"><a class="el" href="group__fifos.html">RTAI FIFO module</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>RTAI FIFO communication functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:rtai__fifos_8h"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtai__fifos_8h.html">rtai_fifos.h</a></td></tr>
<tr class="memdesc:rtai__fifos_8h"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interface of the <a class="el" href="group__fifos.html">RTAI FIFO module</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:fifos_8c"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fifos_8c.html">fifos.c</a></td></tr>
<tr class="memdesc:fifos_8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of the <a class="el" href="group__fifos.html">RTAI FIFO module</a>. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga72931e1a996bee3be656111c0b9bbc72"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga72931e1a996bee3be656111c0b9bbc72">rtf_suspend_timed</a> (int fd, int ms_delay)</td></tr>
<tr class="memdesc:ga72931e1a996bee3be656111c0b9bbc72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suspend a process for some time.  <a href="#ga72931e1a996bee3be656111c0b9bbc72">More...</a><br /></td></tr>
<tr class="separator:ga72931e1a996bee3be656111c0b9bbc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4d01beb645e00605ee4e17d9a9a6efa"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#gaf4d01beb645e00605ee4e17d9a9a6efa">rtf_open_sized</a> (const char *dev, int perm, int size)</td></tr>
<tr class="memdesc:gaf4d01beb645e00605ee4e17d9a9a6efa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a real-time FIFO.  <a href="#gaf4d01beb645e00605ee4e17d9a9a6efa">More...</a><br /></td></tr>
<tr class="separator:gaf4d01beb645e00605ee4e17d9a9a6efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga12a7526624ecdc4e27ce0980dc1b71e4"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga12a7526624ecdc4e27ce0980dc1b71e4">rtf_read_all_at_once</a> (int fd, void *buf, int count)</td></tr>
<tr class="memdesc:ga12a7526624ecdc4e27ce0980dc1b71e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from FIFO in user space, waiting for all of them.  <a href="#ga12a7526624ecdc4e27ce0980dc1b71e4">More...</a><br /></td></tr>
<tr class="separator:ga12a7526624ecdc4e27ce0980dc1b71e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6ada2f6b48619c6c15e068da0252fa6"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#gac6ada2f6b48619c6c15e068da0252fa6">rtf_read_timed</a> (int fd, void *buf, int count, int ms_delay)</td></tr>
<tr class="memdesc:gac6ada2f6b48619c6c15e068da0252fa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from FIFO in user space, with timeout.  <a href="#gac6ada2f6b48619c6c15e068da0252fa6">More...</a><br /></td></tr>
<tr class="separator:gac6ada2f6b48619c6c15e068da0252fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef4c2fc31b90997bbdb87c3d243aa742"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#gaef4c2fc31b90997bbdb87c3d243aa742">rtf_write_timed</a> (int fd, void *buf, int count, int ms_delay)</td></tr>
<tr class="memdesc:gaef4c2fc31b90997bbdb87c3d243aa742"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to FIFO in user space, with timeout.  <a href="#gaef4c2fc31b90997bbdb87c3d243aa742">More...</a><br /></td></tr>
<tr class="separator:gaef4c2fc31b90997bbdb87c3d243aa742"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa07e274f586ecf476d2ef2af583c505d"><td class="memItemLeft" align="right" valign="top">static int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#gaa07e274f586ecf476d2ef2af583c505d">rtf_set_async_sig</a> (int fd, int signum)</td></tr>
<tr class="memdesc:gaa07e274f586ecf476d2ef2af583c505d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Activate asynchronous notification of data availability.  <a href="#gaa07e274f586ecf476d2ef2af583c505d">More...</a><br /></td></tr>
<tr class="separator:gaa07e274f586ecf476d2ef2af583c505d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade991138d100935f0cbc7f8186fd72bf"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#gade991138d100935f0cbc7f8186fd72bf">rtf_reset</a> (unsigned int minor)</td></tr>
<tr class="memdesc:gade991138d100935f0cbc7f8186fd72bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset a real-time FIFO.  <a href="#gade991138d100935f0cbc7f8186fd72bf">More...</a><br /></td></tr>
<tr class="separator:gade991138d100935f0cbc7f8186fd72bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1fad2bb419775edcd521d50f71af3e7b"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga1fad2bb419775edcd521d50f71af3e7b">rtf_resize</a> (unsigned int minor, int size)</td></tr>
<tr class="memdesc:ga1fad2bb419775edcd521d50f71af3e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize a real-time FIFO.  <a href="#ga1fad2bb419775edcd521d50f71af3e7b">More...</a><br /></td></tr>
<tr class="separator:ga1fad2bb419775edcd521d50f71af3e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga68d86674123dc09c3b3bff52d15e1ca2"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga68d86674123dc09c3b3bff52d15e1ca2">rtf_create</a> (unsigned int minor, int size)</td></tr>
<tr class="memdesc:ga68d86674123dc09c3b3bff52d15e1ca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a real-time FIFO.  <a href="#ga68d86674123dc09c3b3bff52d15e1ca2">More...</a><br /></td></tr>
<tr class="separator:ga68d86674123dc09c3b3bff52d15e1ca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3a6901248601fd79ff022594363dc189"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga3a6901248601fd79ff022594363dc189">rtf_destroy</a> (unsigned int minor)</td></tr>
<tr class="memdesc:ga3a6901248601fd79ff022594363dc189"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a real-time FIFO.  <a href="#ga3a6901248601fd79ff022594363dc189">More...</a><br /></td></tr>
<tr class="separator:ga3a6901248601fd79ff022594363dc189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga23f3d01684830922905ee388e44b05c2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga23f3d01684830922905ee388e44b05c2">rtf_create_handler</a> (unsigned int minor, void *handler)</td></tr>
<tr class="memdesc:ga23f3d01684830922905ee388e44b05c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Install a FIFO handler function.  <a href="#ga23f3d01684830922905ee388e44b05c2">More...</a><br /></td></tr>
<tr class="separator:ga23f3d01684830922905ee388e44b05c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e5e96195587b0fa50a58fdefea170b0"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga7e5e96195587b0fa50a58fdefea170b0">rtf_put</a> (unsigned int minor, void *buf, int count)</td></tr>
<tr class="memdesc:ga7e5e96195587b0fa50a58fdefea170b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data to FIFO.  <a href="#ga7e5e96195587b0fa50a58fdefea170b0">More...</a><br /></td></tr>
<tr class="separator:ga7e5e96195587b0fa50a58fdefea170b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1caa49c67a934e2fde6fdd1c628180bd"><td class="memItemLeft" align="right" valign="top">RTAI_SYSCALL_MODE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__fifos__ipc.html#ga1caa49c67a934e2fde6fdd1c628180bd">rtf_get</a> (unsigned int minor, void *buf, int count)</td></tr>
<tr class="memdesc:ga1caa49c67a934e2fde6fdd1c628180bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from FIFO.  <a href="#ga1caa49c67a934e2fde6fdd1c628180bd">More...</a><br /></td></tr>
<tr class="separator:ga1caa49c67a934e2fde6fdd1c628180bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>RTAI FIFO communication functions. </p>
<p>RTAI fifos maintain full compatibility with those available in NMT_RTLinux while adding many other useful services that avoid the clumsiness of Unix/Linux calls. So if you need portability you should bent yourself to the use of select for timing out IO operations, while if you have not to satisfy such constraints use the available simpler, and more direct, RTAI fifos specific services.</p>
<p>In the table below the standard Unix/Linux services in user space are enclosed in []. See standard Linux man pages if you want to use them, they need not be explained here.</p>
<center><table class="doxtable">
<tr>
<td>Called from RT task </td><td>Called from Linux process  </td></tr>
<tr>
<td><a class="el" href="group__fifos__ipc.html#ga68d86674123dc09c3b3bff52d15e1ca2" title="Create a real-time FIFO. ">rtf_create</a> </td><td><a class="el" href="group__fifos__ipc.html#gaf4d01beb645e00605ee4e17d9a9a6efa" title="Create a real-time FIFO. ">rtf_open_sized</a> <br />
 [open]  </td></tr>
<tr>
<td><a class="el" href="group__fifos__ipc.html#ga3a6901248601fd79ff022594363dc189" title="Close a real-time FIFO. ">rtf_destroy</a> </td><td>[close]  </td></tr>
<tr>
<td><a class="el" href="group__fifos__ipc.html#gade991138d100935f0cbc7f8186fd72bf" title="Reset a real-time FIFO. ">rtf_reset</a> </td><td><a class="el" href="group__fifos__ipc.html#gade991138d100935f0cbc7f8186fd72bf" title="Reset a real-time FIFO. ">rtf_reset</a>  </td></tr>
<tr>
<td><a class="el" href="group__fifos__ipc.html#ga1fad2bb419775edcd521d50f71af3e7b" title="Resize a real-time FIFO. ">rtf_resize</a> </td><td><a class="el" href="group__fifos__ipc.html#ga1fad2bb419775edcd521d50f71af3e7b" title="Resize a real-time FIFO. ">rtf_resize</a>  </td></tr>
<tr>
<td><a class="el" href="group__fifos__ipc.html#ga1caa49c67a934e2fde6fdd1c628180bd" title="Read data from FIFO. ">rtf_get</a> </td><td>[read] <br />
 <a class="el" href="group__fifos__ipc.html#gac6ada2f6b48619c6c15e068da0252fa6" title="Read data from FIFO in user space, with timeout. ">rtf_read_timed</a> <br />
 <a class="el" href="group__fifos__ipc.html#ga12a7526624ecdc4e27ce0980dc1b71e4" title="Read data from FIFO in user space, waiting for all of them. ">rtf_read_all_at_once</a>  </td></tr>
<tr>
<td><a class="el" href="group__fifos__ipc.html#ga7e5e96195587b0fa50a58fdefea170b0" title="Write data to FIFO. ">rtf_put</a> </td><td>[write] <br />
 <a class="el" href="group__fifos__ipc.html#gaef4c2fc31b90997bbdb87c3d243aa742" title="Write data to FIFO in user space, with timeout. ">rtf_write_timed</a>  </td></tr>
<tr>
<td><a class="el" href="group__fifos__ipc.html#ga23f3d01684830922905ee388e44b05c2" title="Install a FIFO handler function. ">rtf_create_handler</a> </td><td></td></tr>
<tr>
<td></td><td><a class="el" href="group__fifos__ipc.html#ga72931e1a996bee3be656111c0b9bbc72" title="Suspend a process for some time. ">rtf_suspend_timed</a>  </td></tr>
<tr>
<td></td><td><a class="el" href="group__fifos__ipc.html#gaa07e274f586ecf476d2ef2af583c505d" title="Activate asynchronous notification of data availability. ">rtf_set_async_sig</a>  </td></tr>
</table>
</center><p>In Linux, fifos have to be created by : </p><pre class="fragment">$ mknod /dev/rtf&lt;x&gt; c 150 &lt;x&gt; </pre><p> where &lt;x&gt; is the minor device number, from 0 to 63; thus on the Linux side RTL fifos can be used as standard character devices. As it was said above to use standard IO operations on such devices there is no need to explain anything, go directly to Linux man pages. RTAI fifos specific services available in kernel and user space are instead explained here.</p>
<p>What is important to remember is that in the user space side you address fifos through the file descriptor you get at fifo device opening while in kernel space you directly address them by their minor number. So you will mate the <em>fd</em> you get in user space by using </p><pre class="fragment">open(/dev/rtfxx,...) </pre><p> to the integer <code>xx</code> you will use in kernel space.</p>
<dl class="section note"><dt>Note</dt><dd>RTAI fifos should be used just with applications that use only real time interrupt handlers, so that no RTAI scheduler is installed, or if you need compatibility with NMT RTL. If you are working with any RTAI scheduler already installed you are strongly invited to think about avoiding them, use LXRT instead.</dd></dl>
<p>It is far better and flexible, and if you really like it the fifos way mailboxes are a one to one, more effective, substitute. After all RTAI fifos are implemented on top of them. </p>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga68d86674123dc09c3b3bff52d15e1ca2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rtf_create </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a real-time FIFO. </p>
<p>rtf_create creates a real-time fifo (RT-FIFO) of initial size <em>size</em> and assigns it the identifier <em>fifo</em>. It must be used only in kernel space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minor</td><td>is a positive integer that identifies the fifo on further operations. It has to be less than RTF_NO.</td></tr>
    <tr><td class="paramname">size</td><td>is the requested size for the fifo.</td></tr>
  </table>
  </dd>
</dl>
<p><em>fifo</em> may refer to an existing RT-FIFO. In this case the size is adjusted if necessary.</p>
<p>The RT-FIFO is a character based mechanism to communicate among real-time tasks and ordinary Linux processes. The rtf_* functions are used by the real-time tasks; Linux processes use standard character device access functions such as read, write, and select.</p>
<p>If this function finds an existing fifo of lower size it resizes it to the larger new size. Note that the same condition apply to the standard Linux device open, except that when it does not find any already existing fifo it creates it with a default size of 1K bytes.</p>
<p>It must be remarked that practically any fifo size can be asked for. In fact if <em>size</em> is within the constraint allowed by kmalloc such a function is used, otherwise vmalloc is called, thus allowing any size that can fit into the available core memory.</p>
<p>Multiple calls of this function are allowed, a counter is kept internally to track their number, and avoid destroying/closing a fifo that is still used.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success </td></tr>
    <tr><td class="paramname">ENODEV</td><td>if fifo is greater than or equal to RTF_NO </td></tr>
    <tr><td class="paramname">ENOMEM</td><td>if the necessary size could not be allocated for the RT-FIFO. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="group__fifos__ipc.html#ga1fad2bb419775edcd521d50f71af3e7b">rtf_resize()</a>.</p>

<p>Referenced by <a class="el" href="group__fifos__sem.html#gaecb9728b684b1ae02527741993a19df5">rtf_sem_destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga23f3d01684830922905ee388e44b05c2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int rtf_create_handler </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Install a FIFO handler function. </p>
<p>rtf_create_handler installs a handler which is executed when data is written to or read from a real-time fifo.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minor</td><td>is an RT-FIFO that must have previously been created with a call to <a class="el" href="group__fifos__ipc.html#ga68d86674123dc09c3b3bff52d15e1ca2" title="Create a real-time FIFO. ">rtf_create()</a>.</td></tr>
    <tr><td class="paramname">handler</td><td>is a pointer on a function wich will be called whenever a Linux process accesses that fifo.</td></tr>
  </table>
  </dd>
</dl>
<p>rtf_create_handler is often used in conjunction with <a class="el" href="group__fifos__ipc.html#ga1caa49c67a934e2fde6fdd1c628180bd" title="Read data from FIFO. ">rtf_get()</a> to process data acquired asynchronously from a Linux process. The installed handler calls <a class="el" href="group__fifos__ipc.html#ga1caa49c67a934e2fde6fdd1c628180bd" title="Read data from FIFO. ">rtf_get()</a> when data is present. Because the handler is only executed when there is activity on the fifo, polling is not necessary.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on success. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>if <em>fifo</em> is greater than or equal to RTF_NO, or handler is <code>NULL</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>rtf_create_handler does not check if FIFO referred by <em>fifo</em> is open or not. The next call of rtf_create will uninstall the handler just "installed". </dd></dl>

<p>Referenced by <a class="el" href="group__fifos__sem.html#gaecb9728b684b1ae02527741993a19df5">rtf_sem_destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3a6901248601fd79ff022594363dc189"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rtf_destroy </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a real-time FIFO. </p>
<p>rtf_destroy closes, in kernel space, a real-time fifo previously created or reopened with <a class="el" href="group__fifos__ipc.html#ga68d86674123dc09c3b3bff52d15e1ca2" title="Create a real-time FIFO. ">rtf_create()</a> or <a class="el" href="group__fifos__ipc.html#gaf4d01beb645e00605ee4e17d9a9a6efa" title="Create a real-time FIFO. ">rtf_open_sized()</a>. An internal mechanism counts how many times a fifo was opened. Opens and closes must be in pair. rtf_destroy should be called as many times as rtf_create was. After the last close the fifo is really destroyed.</p>
<p>No need for any particular function for the same service in user space, simply use the standard Unix close.</p>
<dl class="section return"><dt>Returns</dt><dd>a non-negative value on success. Actually it is the open counter, that means how many times rtf_destroy should be called yet to destroy the fifo.</dd>
<dd>
a a negative value is returned as described below. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ENODEV</td><td>if <em>fifo</em> is greater than or equal to RTF_NO. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>if <em>fifo</em> refers to a not opened fifo.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The equivalent of rtf_destroy in user space is the standard UNIX close. </dd></dl>

<p>Referenced by <a class="el" href="group__fifos__sem.html#gaecb9728b684b1ae02527741993a19df5">rtf_sem_destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1caa49c67a934e2fde6fdd1c628180bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rtf_get </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from FIFO. </p>
<p>rtf_get tries to read a block of data from a real-time fifo previously created with a call to <a class="el" href="group__fifos__ipc.html#ga68d86674123dc09c3b3bff52d15e1ca2" title="Create a real-time FIFO. ">rtf_create()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minor</td><td>is the ID with which the RT-FIFO was created. </td></tr>
    <tr><td class="paramname">buf</td><td>points a buffer provided by the caller. </td></tr>
    <tr><td class="paramname">count</td><td>is the size of <em>buf</em> in bytes.</td></tr>
  </table>
  </dd>
</dl>
<p>This mechanism is available only to real-time tasks; Linux processes use a read from the corresponding fifo device to dequeue data from a fifo. Similarly, Linux processes use write or similar functions to write the data to be read via <a class="el" href="group__fifos__ipc.html#ga7e5e96195587b0fa50a58fdefea170b0" title="Write data to FIFO. ">rtf_put()</a> by a real-time task.</p>
<p>rtf_get is often used in conjunction with <a class="el" href="group__fifos__ipc.html#ga23f3d01684830922905ee388e44b05c2" title="Install a FIFO handler function. ">rtf_create_handler()</a> to process data received asynchronously from a Linux process. A handler is installed via <a class="el" href="group__fifos__ipc.html#ga23f3d01684830922905ee388e44b05c2" title="Install a FIFO handler function. ">rtf_create_handler()</a>; this handler calls rtf_get to receive any data present in the RT-FIFO as it becomes available. In this way, polling is not necessary; the handler is called only when data is present in the fifo.</p>
<dl class="section return"><dt>Returns</dt><dd>the size of the received data block on success. Note that this value may be less than count if count bytes of data is not available in the fifo. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ENODEV</td><td>if <em>fifo</em> is greater than or equal to RTF_NO. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>if <em>fifo</em> refers to a not opened fifo.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The equivalent of rtf_get in user space is the standard UNIX read, which can be either blocking or nonblocking according to how you opened the related device. </dd></dl>

<p>Referenced by <a class="el" href="group__fifos__sem.html#gaecb9728b684b1ae02527741993a19df5">rtf_sem_destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf4d01beb645e00605ee4e17d9a9a6efa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rtf_open_sized </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>dev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>perm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a real-time FIFO. </p>
<p>rtf_open_sized is the equivalent of <a class="el" href="group__fifos__ipc.html#ga68d86674123dc09c3b3bff52d15e1ca2" title="Create a real-time FIFO. ">rtf_create()</a> in user space; it creates a real-time fifo (RT-FIFO) of initial size <em>size</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">size</td><td>is the requested size for the fifo.</td></tr>
  </table>
  </dd>
</dl>
<p>The RT-FIFO is a character based mechanism to communicate among real-time tasks and ordinary Linux processes. The rtf_* functions are used by the real-time tasks; Linux processes use standard character device access functions such as read, write, and select.</p>
<p>If this function finds an existing fifo of lower size it resizes it to the larger new size. Note that the same condition apply to the standard Linux device open, except that when it does not find any already existing fifo it creates it with a default size of 1K bytes.</p>
<p>It must be remarked that practically any fifo size can be asked for. In fact if <em>size</em> is within the constraint allowed by kmalloc such a function is used, otherwise vmalloc is called, thus allowing any size that can fit into the available core memory.</p>
<p>Multiple calls of this function are allowed, a counter is kept internally to track their number, and avoid destroying/closing a fifo that is still used.</p>
<dl class="section return"><dt>Returns</dt><dd>the usual Unix file descriptor on succes, to be used in standard reads and writes. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-ENOMEM</td><td>if the necessary size could not be allocated for the RT-FIFO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>In user space, the standard UNIX open acts like rtf_open_sized with a default 1K size. </dd></dl>

</div>
</div>
<a class="anchor" id="ga7e5e96195587b0fa50a58fdefea170b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rtf_put </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data to FIFO. </p>
<p>rtf_put tries to write a block of data to a real-time fifo previously created with <a class="el" href="group__fifos__ipc.html#ga68d86674123dc09c3b3bff52d15e1ca2" title="Create a real-time FIFO. ">rtf_create()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minor</td><td>is the ID with which the RT-FIFO was created. </td></tr>
    <tr><td class="paramname">buf</td><td>points the block of data to be written. </td></tr>
    <tr><td class="paramname">count</td><td>is the size of the block in bytes.</td></tr>
  </table>
  </dd>
</dl>
<p>This mechanism is available only in kernel space, i.e. either in real-time tasks or handlers; Linux processes use a write to the corresponding /dev/fifo&lt;n&gt; device to enqueue data to a fifo. Similarly, Linux processes use read or similar functions to read the data previously written via rtf_put by a real-time task.</p>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written on succes. Note that this value may be less than <em>count</em> if <em>count</em> bytes of free space is not available in the fifo. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">ENODEV</td><td>if <em>fifo</em> is greater than or equal to RTF_NO. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>if <em>fifo</em> refers to a not opened fifo.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The equivalent of rtf_put in user space is the standard UNIX write, which can be either blocking or nonblocking according to how you opened the related device. </dd></dl>

<p>Referenced by <a class="el" href="group__fifos__sem.html#gaecb9728b684b1ae02527741993a19df5">rtf_sem_destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga12a7526624ecdc4e27ce0980dc1b71e4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rtf_read_all_at_once </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from FIFO in user space, waiting for all of them. </p>
<p>rtf_read_all_at_once reads a block of data from a real-time fifo identified by the file descriptor <em>fd</em> blocking till all waiting at most <em>count</em> bytes are available, whichever option was used at the related device opening.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>is the file descriptor returned at fifo open. </td></tr>
    <tr><td class="paramname">buf</td><td>points the block of data to be written. </td></tr>
    <tr><td class="paramname">count</td><td>is the size in bytes of the buffer.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read on success. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-EINVAL</td><td>if <em>fd</em> refers to a not opened fifo. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="gac6ada2f6b48619c6c15e068da0252fa6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rtf_read_timed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ms_delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read data from FIFO in user space, with timeout. </p>
<p>rtf_read_timed reads a block of data from a real-time fifo identified by the file descriptor <em>fd</em> waiting at most <em>delay</em> milliseconds to complete the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>is the file descriptor returned at fifo open. </td></tr>
    <tr><td class="paramname">buf</td><td>points the block of data to be written. </td></tr>
    <tr><td class="paramname">count</td><td>is the size of the block in bytes. </td></tr>
    <tr><td class="paramname">ms_delay</td><td>is the timeout time in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes read is returned on success or timeout. Note that this value may be less than <em>count</em> if <em>count</em> bytes of free space is not available in the fifo or a timeout occured. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-EINVAL</td><td>if <em>fd</em> refers to a not opened fifo.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The standard, clumsy, Unix way to achieve the same result is to use select. </dd></dl>

</div>
</div>
<a class="anchor" id="gade991138d100935f0cbc7f8186fd72bf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rtf_reset </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reset a real-time FIFO. </p>
<p>rtf_reset resets RT-FIFO <em>fd_fifo</em> by setting its buffer pointers to zero, so that any existing data is discarded and the fifo started anew like at its creations. It can be used both in kernel and user space.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minor</td><td>is a file descriptor returned by standard UNIX open in user space while it is directly the chosen fifo number in kernel space.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">0</td><td>on succes. </td></tr>
    <tr><td class="paramname">ENODEV</td><td>if <em>fd_fifo</em> is greater than or equal to RTF_NO. </td></tr>
    <tr><td class="paramname">EINVAL</td><td>if <em>fd_fifo</em> refers to a not opened fifo. </td></tr>
    <tr><td class="paramname">EFAULT</td><td>if the operation was unsuccessful. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group__fifos__sem.html#gaecb9728b684b1ae02527741993a19df5">rtf_sem_destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1fad2bb419775edcd521d50f71af3e7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RTAI_SYSCALL_MODE int rtf_resize </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resize a real-time FIFO. </p>
<p>rtf_resize modifies the real-time fifo fifo, previously created with, <a class="el" href="group__fifos__ipc.html#ga68d86674123dc09c3b3bff52d15e1ca2" title="Create a real-time FIFO. ">rtf_create()</a>, to have a new size of <em>size</em>. Any data in the fifo is discarded.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">minor</td><td>is a file descriptor returned by standard UNIX open in user space while it is directly the chosen fifo number in kernel space.</td></tr>
    <tr><td class="paramname">size</td><td>is the requested new size.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">size</td><td>on success. </td></tr>
    <tr><td class="paramname">-ENODEV</td><td>if <em>fifo</em> is greater than or equal to RTF_NO. </td></tr>
    <tr><td class="paramname">-EINVAL</td><td>if <em>fifo</em> refers to a not opened fifo. </td></tr>
    <tr><td class="paramname">-ENOMEM</td><td>if <em>size</em> bytes could not be allocated for the RT-FIFO. Fifo </td></tr>
    <tr><td class="paramname">-EBUSY</td><td>if <em>size</em> is smaller than actual content size is unchanged. </td></tr>
  </table>
  </dd>
</dl>

<p>Referenced by <a class="el" href="group__fifos__ipc.html#ga68d86674123dc09c3b3bff52d15e1ca2">rtf_create()</a>, and <a class="el" href="group__fifos__sem.html#gaecb9728b684b1ae02527741993a19df5">rtf_sem_destroy()</a>.</p>

</div>
</div>
<a class="anchor" id="gaa07e274f586ecf476d2ef2af583c505d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rtf_set_async_sig </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Activate asynchronous notification of data availability. </p>
<p>rtf_set_async_sig activate an asynchronous signals to notify data availability by catching a user set signal signum.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">signum</td><td>is a user chosen signal number to be used, default is SIGIO.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-EINVAL</td><td>if fd refers to a not opened fifo. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ga72931e1a996bee3be656111c0b9bbc72"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rtf_suspend_timed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ms_delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Suspend a process for some time. </p>
<p>rtf_suspend_timed suspends a Linux process according to <em>delay</em>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>is the file descriptor returned at fifo open, rtf_suspend_timed needs a fifo support. </td></tr>
    <tr><td class="paramname">ms_delay</td><td>is the timeout time in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The standard, clumsy, way to achieve the same result is to use select with null file arguments, for long sleeps, with seconds resolution, sleep is also available. </dd></dl>

</div>
</div>
<a class="anchor" id="gaef4c2fc31b90997bbdb87c3d243aa742"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int rtf_write_timed </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>ms_delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write data to FIFO in user space, with timeout. </p>
<p>rtf_write_timed writes a block of data to a real-time fifo identified by the file descriptor <em>fd</em> waiting at most @æ delay milliseconds to complete the operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fd</td><td>is the file descriptor returned at fifo open. </td></tr>
    <tr><td class="paramname">buf</td><td>points the block of data to be written. </td></tr>
    <tr><td class="paramname">count</td><td>is the size of the block in bytes. </td></tr>
    <tr><td class="paramname">ms_delay</td><td>is the timeout time in milliseconds.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of bytes written on succes. Note that this value may be less than <em>count</em> if <em>count</em> bytes of free space is not available in the fifo. </dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">-EINVAL</td><td>if <em>fd</em> refers to a not opened fifo.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The standard, clumsy, Unix way to achieve the same result is to use select. </dd></dl>

<p>References <a class="el" href="group__fifos__sem.html#ga18244c6a2a2ce798d95f199cd8efd596">rtf_sem_init()</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
